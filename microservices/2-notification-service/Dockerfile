# multi-stage build в Docker.
# Каждый FROM начинает новый слой (stage).
# В первом (AS builder) мы собираем проект (устанавливаем dev-зависимости, компилируем TypeScript и т.д.).
# Во втором (AS runner) мы создаём чистый образ для продакшена, куда копируем только результат сборки и прод-зависимости.

# !каждый FROM начинает новый образ с нуля!

# СТАДИЯ builder НЕ входит в финальный образ (экономия размера/секретов)
# между стадиями ничего не «протекает», кроме того, что вы явно копируете через COPY --from=

# В builder ставим все зависимости (npm ci), чтобы были доступны TypeScript, webpack/esbuild, Babel, линтеры,
# тест‑раннеры и т.п. — без них npm run build просто не выполнится

# Аналогия
# Представь два отдельных компьютера:

# Компьютер #1 - собираешь проект, получаешь папку build/
# Компьютер #2 - берешь только папку build/ с первого компьютера
# Первый компьютер выбрасываешь
# Поэтому финальный образ легкий - в нем нет dev-зависимостей и исходников из первого образа.

# Слои builder-стадии, docker build создает временный образ:
#   L1: FROM node:alpine              (базовый слой)
#   L2: WORKDIR /app
#   L3: COPY package*.json, tsconfig  (кэш-индикатор #1)
#   L4: RUN npm ci                    (дорогой шаг, кэшируется пока L3 не менялся)
#   L5: COPY src                      (кэш-индикатор #2, меняется чаще)
#   L6: RUN npm run build             (создаёт /app/build)

# В runner ставим только прод‑зависимости (npm ci --omit=dev), копируем артефакты сборки
# (например, /app/build) — в прод‑образ не попадают тяжёлые dev‑пакеты
# Между образами ничего не передается, кроме COPY --from=builder

# Слои runner-стадии:
#   R1: FROM node:alpine  - (базовый слой - ЗАНОВО) docker build создает новый образ с нуля
#   R2: ENV / WORKDIR
#   R3: COPY package*.json            (кэш-индикатор #3)
#   R4: RUN npm ci --omit=dev         (ставит только прод deps)
#   R5: COPY --from=builder /app/build ./build

# Если вы изменили только код в src/:
#   → пересоберутся L5, L6
#   → кэш L4 сохранится (быстро)
#   → в runner заново применится R5 (быстро)


# -------------------------------
# СТАДИЯ 1: BUILDER
# Создается ОБРАЗ #1 (временный)
# Имя: builder
# Здесь устанавливаем зависимости (включая dev), собираем проект (TypeScript/webpack и т.п.).
# Получаем артефакты сборки (например, папку /app/build).
# -------------------------------
FROM node:24-alpine3.21 AS builder

# Рабочая директория внутри контейнера
# /app будет создана и станет текущей директорией
WORKDIR /app

# 1) Сначала копируем только файлы манифестов зависимостей.
# Это нужно для эффективного кэширования слоёв: если исходники не менялись,
# повторно скачивать node_modules не придётся.
COPY package*.json ./
# Если сборка зависит от tsconfig.json (TS/tsc/ts-node), его тоже копируем ДО установки deps.
COPY tsconfig.json ./
# ВАЖНО: .npmrc может содержать токены. Не храните секреты в образе.
# Если он нужен для доступа к приватному реестру — лучше использовать BuildKit-секреты.
COPY .npmrc ./

# Обновлять npm глобально обычно не требуется — официальный образ уже содержит актуальную версию.
# Если есть строгая необходимость — закрепляйте конкретную версию, а не latest.
RUN npm install -g npm@10.9.3

# Устанавливаем ЗАВИСИМОСТИ ДЛЯ СБОРКИ (включая devDependencies).
# npm ci:
#  - читает только package-lock.json,
#  - не меняет lock-файл,
#  - повторяет точные версии,
#  - быстрее и детерминированнее, чем npm i.
RUN npm ci --no-audit --no-fund

# 2) Теперь копируем исходники — так слой с node_modules сохранится в кэше,
# даже если меняется код.
# скопирует локальную папку (в Контексте сборки) src в /app/src внутри контейнера
# Контекст сборки — это всё, что находится в папке, откуда вы запускаете docker build (если не указали другой --file и --build-context).
COPY src ./src
COPY tools ./tools

# Собираем проект (например, компиляция TypeScript -> JavaScript в /app/build)
RUN npm run build


# -------------------------------
# СТАДИЯ 2: RUNTIME (прод)
# Создается ОБРАЗ #2 (финальный)
# Имя: runner
# Лёгкий рантайм-образ: только прод-зависимости + собранные артефакты из builder.
# -------------------------------
FROM node:24-alpine3.21 AS runner

# Хорошая практика: объявить прод-окружение.
ENV NODE_ENV=production

WORKDIR /app

# Alpine использует apk — установим curl, если он действительно нужен (например, для HEALTHCHECK).
RUN apk add --no-cache curl

# Копируем только файлы манифестов для установки прод-зависимостей.
COPY package*.json ./
# tsconfig.json в рантайме обычно не нужен — это артефакт сборки/IDE.
# COPY tsconfig.json ./

# .npmrc лучше НЕ копировать в образ (риски утечки секретов).
# Если нужен приватный реестр, используйте BuildKit:
#   RUN --mount=type=secret,id=npmrc,target=/root/.npmrc npm ci --omit=dev
# И не забудьте передавать секрет при сборке: DOCKER_BUILDKIT=1 docker build --secret id=npmrc,src=.npmrc .
# Ниже — безопасный дефолт без .npmrc:
RUN npm ci --omit=dev --no-audit --no-fund

# Копируем собранные артефакты из builder-стадии (исправлено имя алиаса "builder")
COPY --from=builder /app/build ./build

# (Опционально) Если нужен процесс-менеджер — установите pm2 и используйте pm2-runtime.
# Но это увеличит образ. Для простых Node-сервисов достаточно "node build/..".
RUN npm install -g pm2@5
# CMD ["pm2-runtime", "start", "ecosystem.config.js"]

# Сообщаем, какой порт слушает приложение (для информации/документации)
EXPOSE 4001

# Рекомендуется запускать от непривилегированного пользователя.
# В официальном node-образе есть пользователь "node" (UID 1000).
# Дадим права на /app и переключимся.
RUN chown -R node:node /app
USER node

# Основная команда контейнера.
# Если в package.json прописано: "start": "node build/server.js"
# то этот CMD запустит приложение.
CMD ["npm", "run", "start"]

# (Опционально) HEALTHCHECK — включайте, только если у сервиса есть /health или аналог.
# HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
#   CMD curl -fsS http://localhost:4001/health || exit 1


# END
# в обычной сборке Docker автоматически очищает промежуточные образы

# Образ builder НЕ удаляется только если:
# 1. Сборка прервалась с ошибкой
# 2. Используешь флаг --target=builder
# Проверка:
# # Во время сборки (в другом терминале)
# docker images | grep builder  # Увидишь временный образ

# # После сборки
# docker images | grep builder  # Пусто - образ удален
# docker images | grep runner   # Есть финальный образ
